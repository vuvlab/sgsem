
#
# You can learn more about package authoring with RStudio at:
#
#   http://r-pkgs.had.co.nz/
#
# Some useful keyboard shortcuts for package authoring:
#
#   Build and Reload Package:  'Ctrl + Shift + B'
#   Check Package:             'Ctrl + Shift + E'
#   Test Package:              'Ctrl + Shift + T'



##' This function carries out sgSEM principle 3
##'
##' sgSEMp3 builds a network model of multiple continuous variables. Each pair of variables is tested for sensible paring relation chosen from 6 pre-selected common functional forms in linear regression settings. Adjusted R-squared is used for model selection for every pair.
##'
##' P-values reported in the "res.print" field of the return list contains the P-values of estimators of linear regression coefficients. The P-values are ordered in the common order of coefficients, i.e. in the order of increasing exponents. For example, in the quadratic functional form y ~ b0 + b1x + b2x^2, the three P-values correspond two those of \\hat{b0}, \\hat{b1} and \\hat{b2}, respectively. If there are less than 3 coefficients to estimate, the extra P-value field is filled with NA's.
##'
##' @title Semi-supervised Generalized Structural Equation Modeling (sgSEM) - Principle 1
##' @param x A dataframe. By default the first column of it stores the main stressor, second column stores the system response variable and other columns store different intermediate variables.
##' @param All stressors all columns exept column number 2.
##' @param response A character string of the column name of the main response OR a numeric number indexing the column of the main response.
##' @param nlsInits a data frame of initial vectors for nls. Each column corresponds to a coefficient. The data frame can be generated by the genInit() function. Each row is one initial vecotor. Currently the only nls function included is y = a + b * exp(c * x).
##' @return An object of class sgSEMp3, which is a list of the following items:
##'
##' \itemize{
##' \item "table": A matrix. For each row, first column is the response variable, second column is the predictor, the other columns show corresponding summary information: Best functional form, R-squared, adj-R-squared, P-value1, P-value2 and P-value3. The P-values correspond to those of estimators of linear regression coefficients. See details.
##' \item "bestModels": A matrix. First dimension indicates predictors. The second dimension indicates response variables. The i-jth cell of the matrix stores the name of the best functional form corresponding to the j-th response variable regressed on the i-th predictor.
##' \item "allModels":  A three dimensional list. The first dimension indicates predictors. The second dimension indicates response variables. Third dimension indicates the fitting results of all 6 functional forms. The i-j-k-th cell of the list stores a "lm" object, corresponding to the j-th response, i-th predictor and the k-th functional form.
##' }
##'
##' The object has two added attributes:
##'
##' \itemize{
##'
##' \item "attr(res.best, "Step")": A vector. For each variable, it shows in which step it is choosen to be significantly related to response variable.
##'
##' \item "attr(res.best, "diag.Step")": A matrix. First dimension is predictors; second dimension is response variables. Each cell shows in which step the pairwise relation is being fitted.
##' }
##'
##' @export
##'
##' @examples
##' ## Load the sample acrylic data set
##' data(acrylic)
##'
##' ## Run semi-gSEM principle one
##' ans <- sgSEMp3(acrylic, stressors = "IrradTot", response = "YI", nlsInits = genInit(k = 20))
##'
##' ## Plot the result
##' plot(ans)
##'
##' ## Plot result with different R-sqr cutoff
##' plot(ans, cutoff = 0.2)
##'
##' ## Summary
##' summary(ans)
##'
##' ## Extract relations between IrradTot and IAD2
##' cf <- path(ans, from = "IrradTot", to = "IAD2")
##' print(cf)
##'
##' ## Print three components of the result
##' ans$table
##' ans$bestModels
##' ans$allModels

sgSEMp3 <- function(x,
                    stressor = NULL,
                    response = NULL,
                    nlsInits = data.frame(a1 = 1, a2 = 1, a3 = 1)){

  ###############################
  ### Checking stressor and response
  ###############################
  if(!missing(stressor)){
    if(!is.character(stressor)){
      if(is.wholenumber(stressor)){
        if(stressor < 1 | stressor > length(colnames(x)))
          stop("Stressor location out of range!")
        stressor.loc <- stressor
      }
    }else{ if(!(stressor %in% colnames(x))){
      stop(paste0("Stressor '", stressor, "' does not exist!"))
    }
      stressor.loc <- which(colnames(x) == stressor)
    }
    neworder <- 1:length(colnames(x))
    neworder[1] <- stressor.loc
    neworder[stressor.loc] <- 1
    x <- x[neworder]
  }else{
    stressor <- names(x)[-2]  ##It takes all columns as stressors exept col2
  }

  if(!missing(response)){
    response.loc <- which(colnames(x) == response)
    if(!is.character(response)){
      if(is.wholenumber(response)){
        if(response < 1 | response > length(colnames(x)))
          stop("Response location out of range!")
        response.loc <- response
      }
    }else{
      if(!(response %in% colnames(x))){
        stop(paste0("Response '", response, "' does not exist!"))
      }
      response.loc <- which(colnames(x) == response)
    }

    neworder <- 1:length(colnames(x))
    neworder[2] <- response.loc
    neworder[response.loc] <- 2
    x <- x[neworder]
  } else{
    response <- names(x)[2]
  }

  ###############################
  ### The following function fits paired relations
  ###############################
  find.relation <- function(iVar, iResp, criterion = "adj.R2"){
    ## saves all adjusted R2 for all 8 functional forms
    adj.R2 <- rep(0, length(modelNames))
    ## Save "lm" object for all 8 functional forms
    model.res <- vector("list", length(modelNames))
    Resp.v <- x[[iResp]] # data of response variable
    Var.v <- x[[iVar]] # data of predictor
    Resp <- colnames(x)[iResp] # name of response variable
    Var <- colnames(x)[iVar] # name of predictor
    cat("Regress Dep ~ Indep ", Resp, "~", Var, "\n")
    lm4.flag <- TRUE
    lm5.flag <- TRUE

    ##-------------------------
    ## Functional Form 1: Linear
    ##-------------------------
    Rel1 <- paste0(Resp, "~", Var)
    lm1 <- do.call("lm", list(Rel1, data=as.name("x")))
    adj.R2[1] <- summary(lm1)$adj.r.squared
    model.res[[1]] <- lm1
    Res.all[[iVar, iResp, "SL"]] <<- lm1

    ##-------------------------
    ## Functional Form 2: Quadratic
    ##-------------------------
    Rel2 <- paste0(Resp,"~",Var,"+","I(", Var,"^2)")
    lm2 <- do.call("lm", list(Rel2, data = as.name("x")))
    adj.R2[2] <- summary(lm2)$adj.r.squared
    model.res[[2]] <- lm2
    Res.all[[iVar, iResp, "Quad"]] <<- lm2

    ##-------------------------
    ## Functional Form 3: Quadratic (no linear term)
    ##-------------------------
    Rel3 <- paste0(Resp, "~", "I(", Var,"^2)")
    lm3 <- do.call("lm", list(Rel3, data = as.name("x")))
    adj.R2[3] <- summary(lm3)$adj.r.squared
    model.res[[3]] <- lm3
    Res.all[[iVar, iResp, "SQuad"]] <<- lm3

    ##-------------------------
    ## Functional Form 4: Exponential
    ##-------------------------
    lm4.flag <- all(exp(Var.v[!is.na(Var.v)]) != Inf)
    if(lm4.flag){
      Rel4 <- paste0(Resp, "~", "exp(", Var,")")
      lm4 <- do.call("lm", list(Rel4, data = as.name("x")))
      adj.R2[4] <- summary(lm4)$adj.r.squared
      model.res[[4]] <- lm4
      Res.all[[iVar, iResp, "Exp"]] <<- lm4
    }else{
      adj.R2[4] <- -Inf
      model.res[[4]] <- NA
      Res.all[[iVar, iResp, "Exp"]] <<- NA
    }

    ##-------------------------
    ## Functional Form 5: Log
    ##-------------------------
    lm5.flag <- all(Var.v > 0 & Var.v < Inf, na.rm = TRUE)
    if(lm5.flag){
      Rel5 <- paste0(Resp, "~", "log(", Var,")")
      lm5 <- do.call("lm", list(Rel5, data=as.name("x")))
      adj.R2[5] <- summary(lm5)$adj.r.squared
      model.res[[5]] <- lm5
      Res.all[[iVar, iResp, "Log"]] <<- lm5
    }
    else {
      adj.R2[5] <- -Inf
      model.res[[5]] <- NA
      Res.all[[iVar, iResp, "Log"]] <<- NA
    }

    ##-------------------------
    ## Functional Form 6: nls
    ##-------------------------
    ## if(Resp == "G" & Var == "time") browser()

    Rel6 <- paste0(Resp, " ~ ", "a1 + a2 * exp(a3 * ",Var, ")")
    model6 <- NA
    SSE <- NA
    ## Find the best (if any) nls models from all initial values
    for(i in 1:nrow(nlsInits)){
      nls1 <- tryCatch({
        do.call("nls", list(Rel6, data = as.name("x"),
                            start = list(a1 = nlsInits[i, 1],
                                         a2 = nlsInits[i,2], a3 = nlsInits[i,3])))
      }, error = function(e) e)

      if(inherits(nls1, "nls")){
        ## if model6 is still NA, initialize it
        if(!inherits(model6, "nls")){
          model6 <- nls1
          SSE <- sum(residuals(nls1) ^ 2)
          init <- nlsInits[i,]
        }else{
          newSSE <- sum(residuals(nls1) ^ 2)
          if(newSSE < SSE){
            model6 <- nls1
            SSE <- newSSE
            init <- nlsInits[i,]
          }else{}
        }
      }
    }

    ## Assign result
    if(!inherits(model6, "nls")){
      adj.R2[6] <- -Inf
      model.res[[6]] <- NA
      Res.all[[iVar, iResp, "nls"]] <<- NA
    }else{
      R2s <- nlsR2(model6, y = x[[Resp]], p = 3)
      adj.R2[6] <- R2s$adjR2
      model.res[[6]] <- model6
      Res.all[[iVar, iResp, "nls"]] <<- model6
    }

    ##-------------------------
    ## Functional Form 7: Change Point
    ##-------------------------
    ## change <- 0.63
    ## change <- min(Var.v) + (change * (max(Var.v) - min(Var.v)))
    ## Var.new <- as.numeric(Var.v > change)
    ## x$Var.plus <- (Var.v - change) * Var.new
    ## Rel6 <- paste0(Resp,"~", Var, "+", "Var.plus")
    ## browser()
    ## lm6 <- do.call("lm", list(Rel6, data = as.name("x")))
    ## adj.R2[6] <- summary(lm6)$adj.r.squared
    ## model.res[[6]] <- lm6
    ## Res.all[[iVar, iResp, "CPSLSL"]] <<- lm6

    ## fm3DNase1 <- nls(density ~ Asym/(1 + exp((xmid - log(conc))/scal)),
    ##               data = DNase1,
    ##               start = list(Asym = 3, xmid = 0, scal = 1))


   #### This function for changepoint### If added the package becomes too slow
     # breaks <- x[which(x >= min(x) & x <= max(x))]
      #chp <- numeric(length(breaks))
      #for(i in 1:length(breaks)){
       # piecewise1 <- lm(y ~ x*(x < breaks[i]) + x*(x>=breaks[i]))
       # chp[i] <- summary(piecewise1)[6]
      #}
      #chp <- as.numeric(chp)
      #zzz <- breaks[which(chp==min(chp))]
      #brk <- mean(zzz)

      #lm7 <- lm(y ~ x*(x < brk) + x*(x > brk))

      #summary(lm7)




    ##Functional Form 8:

    ## Choose the best model, if no model works, write -1.
    ## Populate the 'table' item in function return.
    ## Populate the 'bestModels' item in function return.
    if(max(adj.R2, na.rm = TRUE) >= 0.001){
      step <- attributes(Res.best)$Step[iResp] + 1
      attributes(Res.best)$Step[iVar] <<-
        min(step, attributes(Res.best)$Step[iVar])
      attributes(Res.best)$diag.Step[iVar, iResp] <<- step
      nbest <- which.max(adj.R2) # location of best model
      Res.best[iVar, iResp] <<- modelNames[nbest]

      ## A row for the print table
      table1r <- matrix(NA, nrow = 1, ncol = nRes)
      colnames(table1r) <- c("Response", "Variable",
                             "Model", "R-Sqr", "adj-R-Sqr",
                             "Pval1", "Pval2", "Pval3")
      table1r <- as.data.frame(table1r)
      table1r[1, c("Response", "Variable")] = c(Resp, Var)
      table1r[1, c("Model")] <- modelNames[nbest]

      ## if(modelNames[nbest] == "nls") browser()
      ## Best model from Resp ~ Var
      finalModel <- model.res[[nbest]]
      if(inherits(finalModel, "lm")){
        model <- summary(finalModel)
        table1r[1,c("R-Sqr", "adj-R-Sqr", "Pval1", "Pval2")] <-
          c(model$r.sq, model$adj.r.sq, model$coef[1,4], model$coef[2,4])
        if(modelNames[nbest] == "Quad"){
          table1r[1, "Pval3"] <- model$coeff[3, 4]
        }else{
          table1r[1, "Pval3"] <- NA
        }
      }else if(inherits(finalModel, "nls")){
        table1r[1,c("R-Sqr", "adj-R-Sqr", "Pval1", "Pval2", "Pval3")] <-
          c(R2s$R2, R2s$adjR2, NA, NA, NA)
      }
      Res.print <<- rbind(Res.print, table1r)
    }else{
      Res.best[iVar, iResp] <<- -1
    }
  }

  ###############################
  ### Main scripts; Above function is called
  ###############################
  nVar <- ncol(x)  #total numb of variables
  nRVar <- nVar - 1  #total numb of possible response variables
  ## Current considered functional forms (Order matters!!!)
  modelNames <- c("SL", "Quad", "SQuad", "Exp", "Log", "nls", "CPSLSL")
  nModel <- length(modelNames)

  ## Initiate Res.all
  Res.all <- vector( "list", nVar * nVar * nModel) #list stores the final results
  dim(Res.all) <- c(nVar, nVar, nModel)
  Res.all[,,] <- NA
  dimnames(Res.all) <- list(colnames(x), colnames(x), modelNames)

  ## Initiate a matrix storing final results
  Res.best <- matrix(rep(NA, nVar * nVar), nrow = nVar,
                     dimnames = list(colnames(x), colnames(x)) )
  attr(Res.best, "Step") <- c(Inf, 0, rep(Inf, nVar-2))
  names(attributes(Res.best)$Step) <- colnames(x)
  attr(Res.best, "diag.Step") <- matrix(rep(Inf, nVar*nVar), nrow = nVar)
  dimnames(attributes(Res.best)$diag.Step) <- list(colnames(x),colnames(x))

  nRes <- 8 # Number of cells in print variable; see below
  ## matrix stores fianl restults, including information of best model name,
  ## R-Sqr, adj-R-Sqr, Pval1, Pval2, Pval3
  Res.print <- matrix(NA, nrow = 0, ncol = nRes)
  colnames(Res.print) <- c("Response", "Variable", "Model", "R-Sqr", "adj-R-Sqr",
                           "Pval1", "Pval2", "Pval3")

  ## indicator of possible response variables have already been tested
  fitted.flag <- rep(FALSE, nRVar)
  ## indicator of possible reponse varibals need to be tested
  tofit.flag <- c(TRUE, rep(FALSE, nRVar-1))

  while(sum(tofit.flag - fitted.flag) != 0){
    iResp <- which(tofit.flag != fitted.flag)[1] + 1
    iVar <- (1 : nVar)[c(-2, -iResp)]
    lapply(iVar, function(x, y) find.relation(x,y), y = iResp)
    tofit.flag <- tofit.flag | (!(Res.best[-1, iResp] %in% c(NA, -1)))
    fitted.flag[iResp - 1] <- TRUE
  }

  ## Outputs are three tables
  res <- list(data = x, stressor = stressor, response = response,
              table = Res.print, bestModels = Res.best, allModels = Res.all)
  class(res) <- c("sgSEMp3","list")
  invisible(res)
}
